# Defense Analysis System

## Purpose

AI-powered security architecture analysis that identifies how security works, analyzes defenses, and generates specific, strategic, actionable architecture-level recommendations across multiple defense areas (not specific vulnerabilities).

### What We Deliver
- ✅ Specific, actionable recommendations: "Add role-based authorization to 12 unprotected admin endpoints"
- ✅ Evidence-backed findings with rationale and implementation guidance
- ✅ Strategic security architecture improvements

### What We Don't Deliver
- ❌ Comprehensive architecture documentation
- ❌ "Here's what exists" inventory reports
- ❌ Specific security vulnerability scanning or risk ratings

### The Mindset
- Think like a security architect delivering strategic findings
- Findings are **opportunities** to improve security posture
- Every finding must have: evidence + recommendation + rationale
- Focus on gaps and improvements, not comprehensive coverage
- Make it actionable: developers should know exactly what to do
- Frame recommendations as suggestions for consideration, not critical demands
- NO risk ratings or doom-and-gloom "what could go wrong" scenarios

## Architecture

Defense analysis follows an **agent architecture** where each defense area (authorization, input validation, crypto, etc.) is an independent AI-powered analyzer.

```
sar/
├── README.md                                # This file
├── docs/
│   ├── DESIGN.md                            # Architecture and design decisions
│   ├── AGENTS.md                            # Agent development guide
│   └── AUTHORIZATION-ANALYSIS.md            # Authorization discovery details
├── agents/
│   ├── __init__.py
│   ├── endpoints.py                         # Endpoint count analysis (test)
│   ├── libraries.py                         # Library/framework analysis (test)
│   ├── endpoint_authorization_analyzer.py   # Route-level access control (TODO)
│   ├── data_authorization_analyzer.py       # Data-level authorization (TODO)
│   ├── input_validation_analyzer.py         # Input validation patterns (TODO)
│   ├── injection_defense_analyzer.py        # Injection defense coverage (TODO)
│   └── ...                                  # Additional defense analyzers
├── defense_analyzer.py                      # Core agent orchestration engine
├── test_pipeline.py                         # Test script
└── __init__.py
```

## Pipeline

### Minimal Defense Analysis Requirements

The defense system requires only 3 inputs:

```
1. CPG (Code Property Graph)
   └─> Generated by Joern for query execution

2. Github Repo files
   └─> Source code, config, build files, etc...

3. Framework files in /frameworks directory

```

## How It Works

### Agent Execution Flow

```
DefenseAnalyzer
    │
    ├─> For each agent:
    │   │
    │   ├─> 1. Mechanism Discovery
    │   │      ├─> Search for standard patterns
    │   │      └─> AI discovers custom patterns (if needed)
    │   │
    │   ├─> 2. Exposure Analysis
    │   │      ├─> Where are the defenses used
    │   │      └─> AI figures out the pattern for where defenses need to be used (exposures)
    │   │
    │   ├─> 2. Detailed Analysis
    │   │      ├─> Is the defense correct?
    │   │      ├─> Is it used everywhere it should be?
    │   │      ├─> Coverage metrics
    │   │      └─> Pattern analysis
    │   │
    │   └─> 3. Finding Generation (AI)
    │          ├─> Analyze evidence
    │          ├─> Identify gaps
    │          └─> Generate recommendations
    │
    └─> Consolidate Results
        └─> One finding per defense area
```

### AI Integration

AI is used in two distinct ways:

**1. Discovery (when needed):**
- **Agentic exploration**: Multi-turn investigation where AI has direct access to tools
- AI writes its own Joern queries, reads source files, searches codebase
- Formulates hypotheses → tests with tools → refines understanding → decides when done
- Tracks confidence and stops at >= 0.9 or after exhausting investigation paths
- Example: Finding `@Superadmin` meta-annotation wrapping `@PreAuthorize` through iterative probing
- See [AGENTIC_DISCOVERY.md](docs/AGENTIC_DISCOVERY.md) for complete approach

**2. Finding Generation (always):**
- Analyzes evidence to identify gaps and opportunities
- Generates strategic recommendations with rationale
- Ensures recommendations are actionable and appropriately framed

## Quick Start

```python
from defenses import DefenseAnalyzer
from compass.cpg_tool import CpgTool

# 1. Get CPG and endpoints from Compass
cpg_tool = CpgTool(cpg_path='auto', project_dir='/path/to/project', auto_generate=True)
architecture = load_from_compass_report('architecture.json')

# 2. Run defense analysis
analyzer = DefenseAnalyzer(
    directory=directory,
    cpg_tool=cpg_tool,
    project_dir='/path/to/project',
    architecture=architecture,
    debug=True
)

results = analyzer.run_all_agents()

### Schema Files

- **Schema**: [`schema/defense-report-schema.json`](schema/defense-report-schema.json) - JSON Schema definition

## Key Features

### Discovers Both Standard and Custom Defense Patterns
- Checks framework definitions first (fast)
- Uses AI to discover custom implementations when needed
- Adapts to project-specific security approaches
- Example: Finding custom `@Superadmin` meta-annotations in Teamserver

### Strategic Recommendations, Not Just Detection of Vulnerabilities
- Focus is on **gaps and opportunities**, not comprehensive documentation
- One finding per defense area (not multiple numbered findings)
- Recommendations framed as suggestions for improvement
- Recommendations should be for standardized defenses, part of existing frameworks if possible.
- Recommendations should be for defenses to be easy to use, simple, powerful, and effective.
- Includes design + implementation + rationale

### Actionable and Evidence-Backed
- Every recommendation backed by evidence (coverage metrics, patterns found)
- Specific examples and locations
- Clear implementation guidance
- Developers know exactly what to do

### Minimal Dependencies
- Only needs CPG and endpoint list from Compass
- Agents are self-contained analyzers
- No framework detection needed
- No complex pipeline dependencies

## Design Principles

1. **Recommendations over Documentation**: Focus on what to improve, not what exists
2. **Single Finding per Area**: One comprehensive finding, not multiple numbered items
3. **AI-Powered Discovery**: Discover custom patterns, don't just check pre-configured lists
4. **Evidence-Backed**: Every recommendation supported by concrete evidence
5. **Actionable**: Developers should know exactly what to do
6. **Appropriately Framed**: Suggestions for consideration, not critical demands


